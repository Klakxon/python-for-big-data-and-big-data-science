# --1 завдання
print("\n1 завдання")
"""Python оптимізує пам’ять для маленьких цілих чисел. Два цілі числа, що належать проміжку від -5 до 256,
будуть посилатися на один і той самий об’єкт в пам’яті. Ось код, який це демонструє:"""
a = 100
b = 100
print(a is b)  # Виведе: True

# --2 завдання
print("\n2 завдання")
"""Щоб перевірити, чи змінна посилається на значення певного типу даних, ви можете використовувати вбудовану 
функцію isinstance(). Наприклад, щоб перевірити, чи змінна True є булевим значенням або цілим числом, ви 
можете виконати наступний код:"""
print(isinstance(True, bool))  # Виведе: True
print(isinstance(True, int))   # Виведе: True

# --3 завдання
print("\n3 завдання")
"""2 змінні, що посилаються на число і дії над ними"""
int_var = 10
float_var = 5.5

print(f"Додавання: {int_var + float_var}")
print(f"Віднімання: {int_var - float_var}")
print(f"Ділення: {int_var / float_var}")
print(f"Множення: {int_var * float_var}")
print(f"Ділення без залишку: {int_var // float_var}")
print(f"Ділення по модулю: {int_var % float_var}")
print(f"Приведення до ступеню: {int_var ** float_var}")

# --4 завдання
print("\n4 завдання")
"""Механізм явного перетворення типів"""
int_float_var = int(float_var)
print(f"Число з рухомою комою перетворене на ціле число: {int_float_var}")
bool_var = True
int_bool_var = int(bool_var)
print(f"Булеве значення перетворене на ціле число: {int_bool_var}")

# --5 завдання
print("\n5 завдання")
"""Створення рядка двома різними способами"""
empty_string1 = ""
empty_string2 = str()

# --6 завдання
print("\n6 завдання")
"""Створення рядка з апострофом і його перетворення на сирий рядок"""
string_with_apostrophe = "It's a string with an apostrophe."
raw_string = r"It's a raw string with an apostrophe."
print(string_with_apostrophe)
print(raw_string)

# --7 завдання
print("\n7 завдання")
"""Створення змінної, що посилається на прізвище, і форматований рядок"""
surname = "Кишенчук"
formatted_string = f"My surname is {surname}"
print(formatted_string)

# --8 завдання
print("\n8 завдання")
"""Перетворення рядка “My dog is crazy.” на список [“my”, “dog”, “is”, “crazy”]"""
sentence = "My dog is crazy."
word_list = sentence.lower().split()
print(word_list)

# --9 завдання
print("\n9 завдання")
"""Створення списку двома різними за синтаксисом способами та обчислення довжини одного з них"""
list1 = [1, 2, 3, 4, 5]
list2 = list((6, 7, 8, 9, 10))
print(f"Довжина першого списку: {len(list1)}")

# --10 завдання
print("\n10 завдання")
"""Створення двох списків та додавання другого списку в якості останнього елемента першого"""
list3 = [1, 2, 3]
list4 = [4, 5, 6]
list3.append(list4)
print(list3)

# --11 завдання
print("\n11 завдання")
"""Створення списку, де елементами цього списку також є списки, та отримання першого елемента з останнього рядка"""
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(nested_list[-1][0])

# --12 завдання
print("\n12 завдання")
"""Створення списку з десяти елементів різного типу та отримання всіх елементів, окрім двох
перших та двох останніх"""
mixed_list = [1, "two", 3.0, "four", True, 6, "seven", 8.0, "nine", False]
new_list = mixed_list[2:-2]
print(new_list)

# --14 завдання
print("\n14 завдання")
"""Створення кортежу з одним елементом"""
single_element_tuple = (1,)

# --15 завдання
print("\n15 завдання")
"""Порівняння списку та кортежу: Списки і кортежі в Python мають багато спільного:
* Обидва є послідовностями, що можуть зберігати різні типи даних.
* Обидва можуть бути індексовані та змінені.
* Обидва можуть бути вкладені.
Однак основна відмінність полягає в тому, що списки є змінними, а кортежі - незмінними. 
Це означає, що ви можете змінювати, додавати або видаляти елементи в списку, але не можете цього робити з кортежем.
Списки зазвичай використовуються для зберігання колекцій елементів, які можуть змінюватися протягом виконання програми,
тоді як кортежі використовуються для зберігання колекцій, які не повинні змінюватися."""

# --16 завдання
print("\n16 завдання")
"""Створення кортежу з 11 елементів чисел з рухомою комою та отримання кожного парного за індексом елемента в зворотньому
порядку"""
float_tuple = (1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9, 10.1, 11.1)
reversed_even_index_elements = float_tuple[-2::-2]
print(reversed_even_index_elements)

# --17 завдання
print("\n17 завдання")
"""Створення множини без елементів та додавання елементів до неї
Множини є змінним типом даних, оскільки ви можете додавати, 
видаляти або змінювати елементи множини"""
s = set()
s.add(1)
s.add(2)
s.add(3)
print(s)

# --18 завдання
print("\n18 завдання")
"""Створення множини зі списку my_list = [1, 1, 2, 67, 67, 8, 9]
Множини в Python не містять дублікатів, тому коли ви перетворюєте список в 
множину, всі дублікати “зникають”."""
my_list = [1, 1, 2, 67, 67, 8, 9]
my_set = set(my_list)
print(my_set)

# --19 завдання
print("\n19 завдання")
"""Створення двох множин та демонстрація операцій об’єднання, різниці, пересічення
та симетричної різниці"""
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

print(f"Об'єднання: {set1.union(set2)}")
print(f"Різниця: {set1.difference(set2)}")
print(f"Пересічення: {set1.intersection(set2)}")
print(f"Симетрична різниця: {set1.symmetric_difference(set2)}")

# --20 завдання
print("\n20 завдання")
"""Створення пустого словника та додавання до нього чотирьох пар елементів з різними типами ключів
Список не може бути ключем у словнику. Це пов’язано з тим, що ключі словника в Python повинні бути незмінними 
(immutable), тоді як списки є змінними (mutable). Це означає, що ви можете змінювати, додавати або видаляти елементи 
списку, що робить його непридатним для використання в якості ключа словника"""
my_dict = {}
my_dict[1] = "integer key"
my_dict["two"] = "string key"
my_dict[3.0] = "float key"
my_dict[True] = "boolean key"
print(my_dict)

# --21 завдання
print("\n20 завдання")
"""Створення словника, де значенням в одній з пар також є словник, який має вкладений словник, та виведення значення,
 що міститься в найбільш внутрішньому словнику"""
nested_dict = {"outer": {"middle": {"inner": "value"}}}
print(nested_dict["outer"]["middle"]["inner"])
